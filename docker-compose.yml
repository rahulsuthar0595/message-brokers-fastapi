version: "3.8"  # version of Docker Compose syntax to use
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: rabbit-mq-web
    restart: always
    env_file: .env
    depends_on:
      - redis
    volumes:
      - .:/rabbit-mq  # Mount the current directory to /usr/src/rabbit-mq in the container. The main reason for using this
      # is to share the code from your local development environment with the Docker container. This is very useful in development because
      # it allows you to make changes to your code on your host machine and have those changes automatically
      # reflected inside the container without rebuilding the Docker image or restarting the container.

  rabbitmq:
    image: "rabbitmq:management"
    ports:
      - "15673:15672"  # Flower's web interface
      - "5673:5672"    # RabbitMQ broker communication
    env_file: .env
    networks:
      - celery_networks
    volumes:
      - .:/rabbit-mq

  celery_worker:
    build: .
    command: celery -A workers.worker worker --loglevel=info
    container_name: rabbit-mq-celery-worker
    networks:
      - celery_networks
    volumes:
      - .:/rabbit-mq

  celery_flower:
    image: mher/flower:latest
    command: celery -A workers.worker flower --loglevel=info
    container_name: rabbit-mq-celery-flower
    ports:
      - "5555:5555"
    depends_on:
      - redis
    networks:
      - celery_networks

  redis:
    image: redis:latest

networks:
  celery_networks: # A network allows containers to communicate with each other and with the outside world. Docker provides several built-in network drivers, including bridge, host, and overlay,
    # to define how containers should connect and communicate. By default, containers run on isolated networks and cannot communicate with each other unless they are connected
    # to the same network. Docker networks facilitate this communication.
    driver: bridge
